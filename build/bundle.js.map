{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./index.js","webpack:///./node_modules/tetris-engine/dist/engine.js","webpack:///./node_modules/tetris-engine/dist/index.js","webpack:///./node_modules/tetris-engine/dist/shape.js","webpack:///./node_modules/tetris-engine/dist/tetra-shapes.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;ACnEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,W;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,CAAC;;;;;;;;;;;;AC1ED;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wC;;AAEA;AACA;AACA,gCAAgC,EAAE;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,wBAAwB;AAC5C;AACA,sBAAsB,gBAAgB,O;AACtC;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA,oBAAoB,mDAAmD;AACvE;AACA,sBAAsB,kCAAkC;AACxD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,e;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,Y;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,c;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA,OAAO;;AAEP,mCAAmC,QAAQ;AAC3C;AACA,oBAAoB,oBAAoB,O;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA,oBAAoB,gBAAgB,O;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,Y;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,gB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,EAAE;AACf,aAAa,EAAE;AACf;AACA;AACA;AACA;;AAEA,kBAAkB,sBAAsB;AACxC;AACA;;AAEA,oBAAoB,gBAAgB;AACpC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA,iD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wB;;;;;;;;;;;AC5YA;AACA;;AAEA,kBAAkB,uB;;;;;;;;;;;ACHlB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,oBAAoB;AAC3C,0BAA0B,qBAAqB;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,QAAQ;AAChD,2CAA2C,SAAS;AACpD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,e;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,qBAAqB;AAC5C;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA,0BAA0B,oBAAoB;AAC9C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,E;;;;;;;;;;;AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./index.js\");\n","let Engine = require('tetris-engine').Engine;\n\nlet App = new Vue({\n   template:\n        `<table class=\"game-table\">\n            <tbody>\n                <tr v-for=\"row in gameState.body\">\n                    <td v-for=\"cell in row\"\n                        v-bind:class=\"cell.cssClasses\">\n                    </td>                    \n                </tr>\n            </tbody>\n        </table>`,\n   el: '#app',\n   data() {       \n      return {\n         gameState: {\n            body: []\n         }\n      };\n   },\n   methods: {\n      render(gameState) {\n         if (gameState.gameStatus == 3) {\n            alert('game over');\n         }\n         this.gameState = gameState;\n      },\n      onKeyDown(e) {\n         if (e && e.key && this) {\n            switch (e.key) {\n               case 'Insert':\n                  this.$gameEngine.rotateBack();\n                  break;\n               case 'Delete':\n                  this.$gameEngine.rotate();\n                  break;\n               case 'ArrowUp':\n                  this.$gameEngine.moveUp();\n                  break;\n               case 'ArrowDown':\n                  this.$gameEngine.moveDown();\n                  break;\n               case 'ArrowLeft':\n                  this.$gameEngine.moveLeft();\n                  break;\n               case 'ArrowRight':\n                  this.$gameEngine.moveRight();\n                  break;\n            }\n         }\n      }\n   },\n   beforeMount() {\n\n      let areaHeight = 15;\n      let areaWidth = 25;\n\n      let defaultHeap = [\n         [0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n      ];\n        \n      this.$gameEngine = new Engine(areaHeight, areaWidth, this.render, defaultHeap);\n\n      window.document.body.addEventListener('keydown', this.onKeyDown.bind(this));\n\n      this.$gameEngine.start();\n      setInterval(()=>{\n         this.$gameEngine.moveDown();\n      }, 1000);\n   }\n});\n","let Shape = require('./shape').Shape\nlet ShapeDimension = require('./shape').ShapeDimension\n\nlet tetraShapes = require('./tetra-shapes')\n\n/**\n * Implements the engine of a game\n */\n\nclass Engine {\n\n  /**\n   * Initializing new area\n   * @param {number} width is the width of the field of the game in squares\n   * @param {number} height is the height of the field of the game in squares\n   * @param {function} renderHandle The method that will be runned every time \n   *                   when game state will be changed. Receives game render data.\n   * @param {Array} default heap for a game\n   */\n  constructor(width = 15, height = 20, renderHandle, defaultHeap, additionalShapes) {\n    if(width <= 0 || height <= 0)\n      throw 'Size parameters of the game field are incorrect'\n\n    this.width = width;\n    this.height = height;\n\n    this._shapesSet = {};\n    for(let key in tetraShapes)\n      this._shapesSet[key] = tetraShapes[key];\n      \n    if(additionalShapes)\n      for(let key in additionalShapes)\n        this._shapesSet[key] = additionalShapes[key];\n\n    this._gameStatus = GAME_STATUS.INIT;    \n\n    this._statistic = {\n      countShapesFalled: 0,\n      countShapesFalledByType: { },\n      countLinesReduced: 0,\n      countDoubleLinesReduced: 0,\n      countTrippleLinesReduced: 0,\n      countQuadrupleLinesReduced: 0\n    }\n\n    this._heap = [];\n    if(defaultHeap && defaultHeap.length && defaultHeap[0].length) {\n\n      for(let y = 0; y < defaultHeap.length; y++) {\n        let row = [];\n        for(let x = 0; x < this.width; x++) { \n          row.push({\n            val: 0\n          });\n        }\n        this._heap.push(row);\n      }\n\n      let inversedDefaultHeap = defaultHeap.slice().reverse();\n      for(let y = 0; y < inversedDefaultHeap.length && y < this.height; y++) {\n        let row = inversedDefaultHeap[y];\n        for(let x = 0; x < row.length && x < this.width; x++) {\n          this._heap[y][x].val = inversedDefaultHeap[y][x]\n        }\n      }\n    }\n\n    this._checkHeapForReduce();\n\n    if(renderHandle) {\n      renderHandle(this.state);\n      this._renderHandle = renderHandle;\n    }\n  }\n\n  /**\n   * Creates a new Shape\n   */\n  _newFigure() {\n    this._shape = this._nextShape ? this._nextShape : new Shape(this._shapesSet, parseInt(this.width / 2 - 3), this.height);\n    this._nextShape = new Shape(this._shapesSet, parseInt(this.width / 2 - 3), this.height);\n\n    let countFalledShapesByThisKind = this._statistic.countShapesFalledByType[this._shape.name];\n    if(!countFalledShapesByThisKind)\n      this._statistic.countShapesFalledByType[this._shape.name] = 1;\n    else \n      this._statistic.countShapesFalledByType[this._shape.name]++;\n\n    this._statistic.countShapesFalled++;\n  }\n\n  /**\n   * Running a game or turn off a pause mode\n   */\n  start() {\n    if(this._gameStatus !== GAME_STATUS.INIT && this._gameStatus !== GAME_STATUS.PAUSE)\n      return false;\n\n    if(this._gameStatus == GAME_STATUS.INIT) {\n      this._newFigure();\n      this._gameStatus = GAME_STATUS.WORK;\n      return true;\n    }\n    \n    if(this._gameStatus == GAME_STATUS.PAUSE) {\n      this._gameStatus = GAME_STATUS.WORK;\n    }\n  }\n\n  /**\n   * Turn on a pause mode\n   */\n  pause() {\n    if(this._gameStatus !== GAME_STATUS.WORK)\n      return false;\n\n    this._gameStatus = GAME_STATUS.PAUSE;\n    return true;\n  }\n\n  moveLeft() {\n    if(this._gameStatus !== GAME_STATUS.WORK)\n     return;\n\n    if(!this._canShapeMove(0, -1))\n      return;\n\n    this._shape.position.X--;\n    this._renderHandle(this.state);\n  }\n\n  moveRight() { \n    if(this._gameStatus !== GAME_STATUS.WORK)\n     return;\n\n    if(!this._canShapeMove(0, 1))\n      return;\n\n    this._shape.position.X++;\n    this._renderHandle(this.state);\n  }\n\n  moveUp() { \n    if(this._gameStatus !== GAME_STATUS.WORK)\n     return;\n     \n    if(!this._canShapeMove(1, 0))\n      return;\n    \n    this._shape.position.Y++;\n    this._renderHandle(this.state);\n  }\n\n  moveDown() { \n    if(this._gameStatus !== GAME_STATUS.WORK)\n     return;\n\n    if(!this._canShapeMove(-1, 0)) {\n      if(!this._addShapeToHeap()) {\n        this._gameStatus = GAME_STATUS.OVER;\n        this._renderHandle(this.state);\n      }\n      return;\n    }\n      \n    \n    this._shape.position.Y--;\n    this._renderHandle(this.state);\n  }\n\n  _addShapeToHeap() {\n    let newRowForHeap = [];\n    for(let i = 0; i < this.width; i++)\n      newRowForHeap.push({\n        val: 0\n      });\n\n    for(let y = ShapeDimension - 1; y >= 0; y--) {\n      let row = this._shape.body[y];\n      for(let x = 0; x < ShapeDimension; x++) { \n          let cell = row[x];\n          if(cell) {\n            let areaIndexY = this._getAreaIndexYFromShape(y);\n            \n            if(areaIndexY >= this.height) {\n              //game over :)\n              return false;\n            }\n\n            while(areaIndexY >= this._heap.length) {\n              this._heap.push(newRowForHeap.slice());\n            }\n\n            let areaIndexX = this._getAreaIndexXFromShape(x);\n            this._heap[areaIndexY][areaIndexX] = {\n              val: 1,\n              class: this._shape.name\n            };\n          }\n      }\n    }\n\n    this._checkHeapForReduce();\n\n    this._newFigure();\n    this._renderHandle(this.state);\n\n    return true;\n  }\n\n  _checkHeapForReduce() {\n    let linesToRemove = [];\n    for(let y = this._heap.length - 1; y >= 0; y--) {\n      let row = this._heap[y];\n      let isThereEmptySquare = false;\n      for(let x = 0; x < row.length; x++) { \n        if(!this._heap[y][x].val) {\n          isThereEmptySquare = true;\n          break;\n        }\n      }\n\n      if(!isThereEmptySquare)\n        linesToRemove.push(y);\n    }\n\n    let newHeap = []\n    for (let y = 0; y < this._heap.length; y++) {\n      if(linesToRemove.indexOf(y) == -1)\n        newHeap.push(this._heap[y]);\n    }\n\n    this._statistic.countLinesReduced += linesToRemove.length;\n    switch(linesToRemove.length) {\n      case 2:\n        this._statistic.countDoubleLinesReduced++;\n        break;\n      case 3:\n        this._statistic.countTrippleLinesReduced++;\n        break;\n      case 4: \n        this._statistic.countQuadrupleLinesReduced++;\n        break;\n    }\n\n    this._heap = newHeap;\n  }\n\n  rotate() { \n    if(this._gameStatus !== GAME_STATUS.WORK)\n     return;\n    \n    if(!this._canShapeMove(0, 0, this._shape.getRotatedBody()))\n      return;\n      \n    this._shape.rotate();\n    this._renderHandle(this.state);\n  }\n\n  rotateBack() { \n    if(this._gameStatus !== GAME_STATUS.WORK)\n     return;\n\n    if(!this._canShapeMove(0, 0, this._shape.getRotatedBackBody()))\n      return;\n    \n    this._shape.rotateBack();\n    this._renderHandle(this.state);\n  }\n\n  _getShapeIndexX(x) {\n    return x - this._shape.position.X;\n  }\n\n  _getShapeIndexY(y) {\n    return this._shape.position.Y + (ShapeDimension - 1) - y;\n  }\n\n  _getAreaIndexXFromShape(shapeX, delta = 0) {\n    return shapeX + this._shape.position.X + delta;\n  }\n\n  _getAreaIndexYFromShape(shapeY, delta = 0) {\n      return this._shape.position.Y + (ShapeDimension - 1) - shapeY + delta;\n  }\n\n  /**\n   * Specifies that can a shape move. \n   * If new coordinates of shape overlap with coordinates of heap \n   * or are outside the game area the shape can't move\n   * @param {*} deltaY specifies vertical moving distance\n   * @param {*} deltaX specifies horizontal moving distance\n   * @param {*} shapeBody specifies changed body of a shape, for example rotated body\n   */\n  _canShapeMove(deltaY, deltaX, shapeBody) {\n    if(!shapeBody)\n      shapeBody = this._shape.body;\n\n    for(let y = 0; y < shapeBody.length; y++) {\n      let row = shapeBody[y];\n      let areaIndexY = this._getAreaIndexYFromShape(y, deltaY);\n      \n      for(let x = 0; x < row.length; x++) {\n        let cell = row[x];\n        if(cell) {\n          let areaIndexX = this._getAreaIndexXFromShape(x, deltaX);\n\n          //check will the shape go over the walls and the ground\n          if(areaIndexY < 0 || areaIndexX < 0 || areaIndexX >= this.width)\n            return false;\n\n          if(this._isHeapSquare(areaIndexY, areaIndexX ))\n            return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  _isShapeSquare(y, x) {\n      if(!this._shape || !this._shape.body)\n        return false;\n      let row = this._shape.body[this._getShapeIndexY(y)];\n      return row && row[this._getShapeIndexX(x)];\n  }\n\n  _isHeapSquare(y, x) {\n    if(!this._heap)\n      return false;\n\n    return this._heap[y] && this._heap[y][x].val;\n  }\n\n  _getHeapClass(y, x) {\n    if(!this._heap)\n      return;\n\n    if(!this._heap[y] || !this._heap[y][x].val)\n      return;\n\n    return this._heap[y][x].class;\n  }\n\n  _getBody() {\n    let body = [];\n    for (let y = this.height - 1; y >= 0; y--) {\n        let row = [];\n        for (let x = 0; x < this.width; x++) {\n          let isHeap = this._isHeapSquare(y, x);\n          let isShape = this._isShapeSquare(y, x);\n          let val = isHeap ? 2 : isShape ? 1 : 0; \n\n          row.push({\n              val: val,\n              cssClasses: [\n                isShape ? 'shape' : null,\n                isHeap ? 'heap' : null,\n                isShape ? this._shape.name + '' : null,\n                isHeap ? this._getHeapClass(y, x) : null\n              ]\n          });\n        }\n        body.push(row);\n\n    }\n    return body;\n  }\n\n  get state() {\n    return {\n      gameStatus: this._gameStatus,\n      body: this._getBody(),\n      shapeName: this._shape ? this._shape.name : null,\n      nextShapeName: this._nextShape ? this._nextShape.name : null,\n      nextShapeBody: this._nextShape ? this._nextShape.body : null,\n      statistic: this._statistic\n    }\n  }\n}\n\n/**\n * Enum represents status of a game\n * \n * INIT - game was not started\n * WORK - game is running\n * PAUSE - game was temporary stopped\n * OVER - game was finished\n */\nconst GAME_STATUS = {\n  INIT: 0,\n  WORK: 1,\n  PAUSE: 2,\n  OVER: 3\n}\n\nmodule.exports = Engine;","let Engine = require('./engine')\nlet tetraShapes = require('./tetra-shapes')\n\nmodule.exports = { Engine, tetraShapes };","/**\n * Max dimension of every shape\n */\nconst ShapeDimension = 5;\n\n/**\n * Implements a falling shape\n */\nclass Shape {\n    constructor(shapesSet, X = 5, Y = 12) {\n        if(!shapesSet)\n            console.error('Set of shapes was not setted!')\n\n        this._shape = this._selectNextShape(shapesSet);\n\n        this.position = {\n           X: X,\n           Y: Y\n        };\n\n        this._calculateProperties();\n     }\n\n     /**\n      * Selecting next shape from the available set of shapes\n      * @private\n      */\n     _selectNextShape(shapesSet) {\n        let count = 0;\n        let selectedShape;\n        for (let prop in shapesSet) {\n           if (Math.random() < 1 / ++count)\n              selectedShape = prop;\n        }\n        \n        this.name = selectedShape;\n\n        return shapesSet[selectedShape];\n     }\n\n     /**\n      * Calculating all properties that change when a shape is rotated\n      * @private\n      */\n     _calculateProperties() {\n        this._calculatePaddings();\n     }\n\n     /**\n      * Calculating paddings\n      */\n     _calculatePaddings() {\n        let paddingLeft = ShapeDimension;\n        let paddingRight = ShapeDimension;\n        let paddingTop = -1;\n        let paddingBottom = -1;\n  \n        for (let y = 0; y < ShapeDimension; y++) {\n           for (let x = 0;  x < ShapeDimension; x++) {\n              if (this._shape[y][x]) {\n                if (paddingLeft > x)\n                   paddingLeft = x;\n\n                if (paddingTop < 0) \n                     paddingTop = y;\n              }\n           }\n        }\n  \n        for (let y = ShapeDimension - 1; y >= 0; y--) {\n           for (let x = ShapeDimension - 1;  x >= 0; x--) {\n              if (this._shape[y][x]) {\n                if (paddingRight > ShapeDimension - 1 - x)\n                    paddingRight = ShapeDimension - 1 - x;\n  \n                if (paddingBottom < 0)\n                    paddingBottom = ShapeDimension - 1 - y;\n              }\n           }\n        }\n  \n        this._paddingLeft = paddingLeft;\n        this._paddingRight = paddingRight;\n        this._paddingTop = paddingTop;\n        this._paddingBottom = paddingBottom;\n     }\n\n     /**\n      * rotating a shape clockwise\n      * @public\n      */\n     rotate() {  \n        this._shape = this.getRotatedBody();\n        this._calculateProperties();\n     }\n\n     getRotatedBody() {\n        let newShape = [];\n  \n        for (let x = 0;  x < ShapeDimension; x++) {\n           let newRow = [];\n           for (let y = ShapeDimension - 1; y >= 0; y--) {\n              newRow.push(this._shape[y][x]);\n           }\n           newShape.push(newRow);\n        }\n\n        return newShape;\n     }\n  \n     /**\n      * rotating a shape counterclockwise\n      * @public\n      */\n     rotateBack() {\n        this._shape = this.getRotatedBackBody();\n        this._calculateProperties();\n     }\n\n     getRotatedBackBody() {\n        let newShape = [];\n        for (let x = ShapeDimension - 1;  x >= 0; x--) {\n           let newRow = [];\n           for (let y = 0; y < ShapeDimension; y++) {\n              newRow.push(this._shape[y][x]);\n           }\n           newShape.push(newRow);\n        }\n\n        return newShape;\n     }\n\n     /**\n      * getting actual shape body\n      * @public\n      */\n     get body() {\n        return this._shape;\n     }\n  \n     /**\n      * getting top padding for shape relatively shape's border\n      * @public\n      */\n     get paddingTop() {\n        return this._paddingTop;\n     }\n  \n    /**\n      * getting bottom padding for shape relatively shape's border\n      * @public\n      */\n     get paddingBottom() {\n        return this._paddingBottom;\n     }\n  \n    /**\n      * getting right padding for shape relatively shape's border\n      * @public\n      */\n     get paddingRight() {\n        return this._paddingRight;\n     }\n\n    /**\n      * getting left padding for shape relatively shape's border\n      * @public\n      */\n     get paddingLeft() {\n        return this._paddingLeft;\n     }\n}\n\nmodule.exports = {\n    Shape,\n    ShapeDimension\n};","module.exports = {\n    IShape: [\n       [0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0],\n       [1, 1, 1, 1, 0],\n       [0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0],\n    ],\n    ZShape: [\n       [0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0],\n       [0, 1, 1, 0, 0],\n       [0, 0, 1, 1, 0],\n       [0, 0, 0, 0, 0],\n    ],\n    SShape: [\n       [0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0],\n       [0, 0, 1, 1, 0],\n       [0, 1, 1, 0, 0],\n       [0, 0, 0, 0, 0],\n    ],\n    LShape: [\n       [0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0],\n       [0, 1, 1, 1, 0],\n       [0, 1, 0, 0, 0],\n       [0, 0, 0, 0, 0],\n    ],\n    JShape: [\n       [0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0],\n       [0, 1, 1, 1, 0],\n       [0, 0, 0, 1, 0],\n       [0, 0, 0, 0, 0],\n    ],\n    OShape: [\n       [0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0],\n       [0, 1, 1, 0, 0],\n       [0, 1, 1, 0, 0],\n       [0, 0, 0, 0, 0],\n    ],\n    TShape: [\n       [0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0],\n       [0, 1, 1, 1, 0],\n       [0, 0, 1, 0, 0],\n       [0, 0, 0, 0, 0],\n    ]\n };\n "],"sourceRoot":""}